<!DOCTYPE html>
<html lang="de" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KerrCode 2.0: Finale Version (HORIZONTBBNSAFE4)</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script>
        // Tailwind Config (Placeholder)
        tailwind.config = {
          darkMode: 'class',
          theme: {
            extend: {
              colors: {
                bgLight: '#f8fafc', bgDark: '#0f172a', textLight: '#1e293b', textDark: '#e2e8f0',
                primary: '#5D5CDE', accent1: '#5D9CDE', accent2: '#8b5cf6', accent3: '#9CDE5D',
                lightAccent: '#f1f5f9', darkAccent: '#1e293b', heading: '#1e3a8a', phaseTransition: '#8b5cf6',
                // Colors for C-Test & Alpha_eff Test & Tau Chart
                cOriginalContinuous: '#5D5CDE', // Original C, Continuous Alpha (Accent1)
                cOriginalBinary: '#A855F7',    // Original C, Binary Alpha (Purple 500, dashed)
                cLower: '#F59E0B',           // Lower C (Amber 500)
                cHigher: '#EF4444',          // Higher C (Red 500)
                cExtra: '#10B981',           // Extra C (Emerald 500)
                tauLambdaCont: '#5D5CDE',    // Tau Lambda Continuous
                tauLambdaBin: '#A855F7',     // Tau Lambda Binary (dashed)
                tauE: '#F59E0B',             // Tau_e
                hubbleTime: '#6B7280',       // Hubble Time H^-1 (Gray 500)
              },
              fontFamily: { sans: ['Inter', 'sans-serif'], serif: ['Merriweather', 'serif'], },
            },
          },
          plugins: [],
        }

        // Dark Mode Logic
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
          document.documentElement.classList.add('dark')
        } else { document.documentElement.classList.remove('dark') }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) { document.documentElement.classList.add('dark'); localStorage.theme = 'dark'; }
            else { document.documentElement.classList.remove('dark'); localStorage.theme = 'light'; }
            setTimeout(() => { // Redraw charts on theme change
                if (typeof initAlphaChart === 'function') initAlphaChart();
                if (typeof initDeltaTChart === 'function') initDeltaTChart();
                if (typeof initTauChart === 'function') initTauChart(); // Add Tau Chart redraw
            }, 50);
        });
    </script>
    <style>
        /* Basic Styles */
        .dark { color-scheme: dark; } .dark .math { color: #e2e8f0; } .dark .MathJax { color: #f3f4f6 !important; }
        .paper-container { transition: background-color 0.3s ease, box-shadow 0.3s ease; }
        .equation-container { padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 2px 5px rgba(0,0,0,0.05); border: 1px solid rgba(0,0,0,0.05); transition: background-color 0.3s ease; margin-bottom: 1.5rem; }
        .dark .equation-container { border-color: rgba(255,255,255,0.1); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .equation-content { text-align: center; font-size: 1.1rem; overflow-x: auto; padding: 0.5rem 0; }
        h3, h4, li, p { color: inherit; } h3 { font-family: 'Merriweather', Georgia, serif; } strong { font-weight: bold; color: inherit; }
        .section-heading { display: flex; align-items: center; margin-bottom: 1.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid #e5e7eb; position: relative; }
        .dark .section-heading { border-bottom-color: #374151; }
        body { counter-reset: section; }
        .section-number::before { counter-increment: section; content: counter(section); display: inline-block; background-color: #5D5CDE; color: white; font-weight: bold; padding: 0.25rem 0.6rem; border-radius: 50%; margin-right: 0.8rem; font-size: 0.9em; line-height: 1.2; }
        .dark .section-number::before { background-color: #8b5cf6; }
        .highlight-box { border-left-width: 4px; padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1.5rem; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .simulation-setup { background-color: rgba(139, 92, 246, 0.05); border-color: #8b5cf6; }
        .dark .simulation-setup { background-color: rgba(139, 92, 246, 0.1); }
        .result-box { background-color: rgba(156, 222, 93, 0.05); border-color: #9CDE5D; }
        .dark .result-box { background-color: rgba(156, 222, 93, 0.1); }
        .highlight { background-color: rgba(250, 204, 21, 0.2); padding: 0.1em 0.3em; border-radius: 0.2em; }
        .dark .highlight { background-color: rgba(250, 204, 21, 0.3); }
        .chart-container { position: relative; height: 450px; margin: 20px 0; background-color: rgba(255, 255, 255, 0.7); border-radius: 0.75rem; padding: 1rem; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); transition: background-color 0.3s ease, box-shadow 0.3s ease; }
        .dark .chart-container { background-color: rgba(30, 41, 59, 0.7); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); }
        .dark-toggle { position: fixed; top: 1rem; right: 1rem; background-color: rgba(255, 255, 255, 0.8); color: #374151; padding: 0.5rem; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 50; transition: background-color 0.3s ease, color 0.3s ease; }
        .dark .dark-toggle { background-color: rgba(30, 41, 59, 0.8); color: #e5e7eb; }
        .phase-box { transition: transform 0.2s ease; } .phase-box:hover { transform: translateY(-2px); }
        .fadeIn { animation: fadeInAnimation 0.8s ease-out forwards; opacity: 0; } @keyframes fadeInAnimation { to { opacity: 1; } }
        .animate-float { animation: floatAnimation 6s ease-in-out infinite; } @keyframes floatAnimation { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }

        /* Legend Hover Style (via JS) */
        .chart-container {
            --legend-opacity: 0.6; /* Default opacity set via CSS variable */
            transition: --legend-opacity 0.3s ease; /* Smooth transition for opacity */
        }
        /* Targeting the legend generated by Chart.js v4 */
        .chart-container .chartjs-legend, /* Fallback for older structures if needed */
        .chart-container canvas + div[role="legend"] { /* More specific target for v4 */
            opacity: var(--legend-opacity); /* Apply opacity using the variable */
            transition: opacity 0.3s ease; /* Ensure transition applies here too */
        }

         /* Chart Draw Animation */
        .chart-container canvas {
            /* animation: drawLine 1s ease-in-out; */ /* Can be distracting, keep optional */
        }
        @keyframes drawLine {
            0% { stroke-dashoffset: 1000; opacity: 0; } /* Example for line drawing */
            100% { stroke-dashoffset: 0; opacity: 1; }
        }
         @keyframes fadeInChart { /* Simple fade-in */
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        .chart-container canvas.chart-rendered { /* Apply fade-in once rendered */
             animation: fadeInChart 0.8s ease-out;
        }

    </style>
</head>
<body class="bg-bgLight dark:bg-bgDark text-textLight dark:text-textDark transition-colors duration-300 font-sans antialiased">
    <div class="dark-toggle" id="darkModeToggle" title="Toggle Dark Mode">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden dark:block" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 block dark:hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>
    </div>

    <div class="min-h-screen pb-20">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8 py-16 max-w-6xl paper-container bg-white/90 dark:bg-gray-900/90 backdrop-blur-sm shadow-xl rounded-lg mt-10 mb-10">
            <header class="relative text-center mb-16 fadeIn">
                <div class="absolute inset-x-0 top-0 h-1.5 bg-gradient-to-r from-accent1 via-accent2 to-accent3 rounded-t-lg"></div>
                <div class="inline-block p-3 bg-primary/10 dark:bg-primary/20 rounded-full mb-4 mt-8 animate-float">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-14 w-14 text-primary" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                </div>
                <h1 class="text-4xl md:text-5xl font-bold mb-6 text-heading dark:text-blue-300 font-serif">
                     Vereinheitlichte α(z)-Dynamik & δT/T Dämpfung (BBN-Safe)
                </h1>
                <p class="text-xl md:text-2xl text-gray-600 dark:text-gray-400 font-serif max-w-4xl mx-auto">
                    Phasenübergang bei \(z_t \gtrsim 10^{10}\) löst Horizontproblem, schont BBN und dämpft Fluktuationen
                </p>
                <div class="mt-10 mb-6 p-4 bg-lightAccent dark:bg-darkAccent rounded-xl inline-block shadow-lg">
                    <p class="font-semibold text-lg text-gray-800 dark:text-gray-200">Gabriel ϕ</p>
                </div>
            </header>

            <main>
                <section class="mb-16 fadeIn">
                    <div class="section-heading">
                        <span class="section-number"></span>
                        <h3 class="text-2xl md:text-3xl font-bold text-heading dark:text-accent1">Die (aktualisierte) vereinheitlichte α(z)-Funktion</h3>
                    </div>
                    <div class="highlight-box simulation-setup">
                        <p class="text-lg md:text-xl font-semibold mb-4 text-center text-phaseTransition dark:text-violet-300">
                            Eine Formel für alle Epochen mit frühem Übergang:
                        </p>
                        <div class="equation-container bg-white/80 dark:bg-gray-800/80 mb-6">
                            <div class="equation-content math">
                                \[ \alpha(z) = \underbrace{A_{\text{früh}} \cdot \left(\frac{1}{1 + e^{k(z-z_t)}}\right)}_{\text{Frühes Univ. (Sigmoid)}} + \underbrace{\alpha_0 + A_{\text{spät}} \cdot \tanh(2(z-z_*))}_{\text{Spätes Univ. (Tanh)}} \]
                            </div>
                        </div>
                        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 text-sm">
                             <div class="p-3 bg-violet-100 dark:bg-violet-900/30 rounded phase-box"><strong>\(A_{\text{früh}} \approx 10\)</strong><br>CMB Glättung</div>
                             <div class="p-3 bg-violet-100 dark:bg-violet-900/30 rounded phase-box"><strong>\(z_t = 10^{10}\)</strong><br>Sehr früher Übergang</div>
                             <div class="p-3 bg-blue-100 dark:bg-blue-900/30 rounded phase-box"><strong>\(\alpha_0 = -0.65\)</strong><br>Basis Spätzeit</div>
                             <div class="p-3 bg-blue-100 dark:bg-blue-900/30 rounded phase-box"><strong>\(A_{\text{spät}} = 1.10\)</strong><br>Amplitude Spätzeit</div>
                             <div class="p-3 bg-blue-100 dark:bg-blue-900/30 rounded phase-box"><strong>\(z_* = 0.70\)</strong><br>Übergang Spätzeit</div>
                             <div class="p-3 bg-gray-100 dark:bg-gray-700/40 rounded phase-box"><strong>\(k \approx 10/z_t\)</strong><br>Steilheit (angepasst)</div>
                             <div class="p-3 bg-accent3/10 dark:bg-accent3/20 rounded phase-box"><strong>\(\beta = 0.040\)</strong><br>(Unverändert)</div>
                        </div>
                        <p class="text-xs italic mt-4 text-center text-gray-600 dark:text-gray-400">Parameter für frühe Phase (\(A_{\text{früh}}, z_t, k\)) sind illustrativ und müssten genauer bestimmt werden.</p>
                    </div>

                    <div class="mt-10">
                        <h4 class="text-lg md:text-xl font-semibold mb-4 text-center text-primary dark:text-accent1">
                            Evolution von \(\alpha(z)\) mit frühem Phasenübergang (Logarithmische Skala)
                        </h4>
                        <div class="chart-container">
                            <canvas id="alphaChart"></canvas>
                        </div>
                         <p class="text-sm text-center text-gray-600 dark:text-gray-400 mt-2">
                             Zeigt das hohe Plateau (\(\alpha \approx 10\)) bei \(z > z_t\), den Übergang bei \(z_t=10^{10}\) und das Tanh-Verhalten bei \(z \ll z_t\).
                         </p>
                    </div>
                </section>

                 <section class="mb-16 fadeIn">
                     <div class="section-heading">
                         <span class="section-number"></span>
                         <h3 class="text-2xl md:text-3xl font-bold text-heading dark:text-accent1">Warum BBN jetzt sicher ist</h3>
                     </div>
                     <div class="highlight-box result-box">
                         <p class="text-base md:text-lg leading-relaxed mb-4">
                             Indem der Phasenübergang auf \(z_t \gtrsim 10^{10}\) verschoben wird, stellt das GDE-Modell sicher, dass zur Zeit der Big Bang Nucleosynthesis (BBN, \(z \sim 10^8 - 10^9\)) der Wert von \(\alpha(z)\) bereits auf sein spätes Plateau (\(\alpha \approx \alpha_0 + A_{spät} \approx 0.45\)) abgefallen ist.
                         </p>
                         <p class="text-base md:text-lg leading-relaxed">
                              Bei diesem kleinen \(\alpha\)-Wert ist der Einfluss von \(\Lambda(z)\) auf die Expansionsrate \(H(z)\) während der BBN <strong class="font-semibold highlight">vernachlässigbar klein</strong> im Vergleich zur dominanten Strahlungsdichte. Die Elementhäufigkeiten (Helium-4, Deuterium) werden somit <strong class="font-semibold highlight">nicht signifikant verändert</strong> und bleiben konsistent mit den Beobachtungen (\(Y_p \approx 0.245\)). <span class="font-bold text-accent3">BBN ist chill! 😎</span>
                         </p>
                     </div>
                 </section>

                 <section class="mb-16 fadeIn">
                     <div class="section-heading">
                         <span class="section-number"></span>
                         <h3 class="text-2xl md:text-3xl font-bold text-heading dark:text-accent1">CMB Fluktuations-Dämpfung durch hohes α</h3>
                     </div>
                     <p class="mb-6 text-base md:text-lg leading-relaxed text-gray-700 dark:text-gray-300">
                         Der hohe Wert von \(\alpha \approx 10\) bei \(z > z_t\) führt zu einer exponentiellen Dämpfung primordialer Fluktuationen \(\delta T/T\). Dieser Mechanismus kann das Horizontproblem lösen, indem er ursprünglich kausal unverbundene Regionen auf die beobachtete Isotropie (\(\delta T/T \sim 10^{-5}\)) bei der Rekombination (\(z \approx 1100\)) glättet.
                     </p>
                     <div class="highlight-box simulation-setup">
                         <p class="text-lg md:text-xl font-semibold mb-4 text-center text-phaseTransition dark:text-violet-300">
                             Modellierte Dämpfung von \(\delta T/T\):
                         </p>
                         <div class="equation-container bg-white/80 dark:bg-gray-800/80 mb-6">
                             <div class="equation-content math">
                                 \[ \frac{\delta T}{T}(z) \approx \left(\frac{\delta T}{T}\right)_0 \exp\left( - C \int_z^{z_{\text{max}}} (1+z')^{\alpha_{\text{eff}}(z')-1} dz' \right) \]
                             </div>
                             <p class="text-sm mt-4 text-gray-700 dark:text-gray-300 px-2">
                                 Diese Formel modelliert die Dämpfung phänomenologisch. Der Term \((1+z')^{\alpha_{\text{eff}}-1}\) fängt den dominanten Effekt eines hohen \(\alpha\) auf die Dämpfungsrate ein. \(\alpha_{\text{eff}}(z')\) ist hier das volle \(\alpha(z')\). Die Dämpfungskonstante \(C\) wird empirisch angepasst, um \(\delta T/T \approx 10^{-5}\) bei \(z=1100\) zu erreichen. Eine mögliche physikalische Skalierung ist \(C \sim \kappa H(z_t)\), wobei die dimensionslose Kopplung \(\kappa \sim T(z_t)/m_{\text{Planck}} \sim 3 \, \text{MeV}/10^{15} \, \text{GeV} \sim 10^{-9}\) sein könnte (Annahme \(m_{\text{Planck}} \sim 10^{19}\) GeV / c² ist hier zu hoch, eher GUT-Skala \(10^{15}\) GeV für \(T(z_t)\)). Dies ergibt \(C \sim 10^{-9} H(z_t) \sim 10^{-33} \, \text{s}^{-1}\) (mit \(H(z_t)\) in Strahlungsdominanz), was grob mit dem empirischen Fit (\(C \approx 2 \times 10^{-33}\)) übereinstimmt, aber einer detaillierteren Herleitung bedarf.
                             </p>
                         </div>
                         <p class="text-base md:text-lg leading-relaxed text-gray-700 dark:text-gray-300 mb-4">
                             Die <strong class="font-semibold highlight">Hauptdämpfung findet bei hohen Rotverschiebungen (\(z > z_t = 10^{10}\)) statt</strong>, wo \(\alpha_{\text{eff}}(z) \approx 10\) ist. Der erreichte Dämpfungsgrad (\(\delta T/T \sim 10^{-5}\)) bleibt dann bis zur Rekombination (\(z \approx 1100\)) weitgehend erhalten.
                         </p>
                         <p class="text-base md:text-lg leading-relaxed text-gray-700 dark:text-gray-300">
                             Die Glättung wirkt über <strong class="font-semibold highlight">alle relevanten Skalen</strong> hinweg durch ein globales thermodynamisches Feedback. Dieses Feedback, getrieben durch das hohe \(\alpha\), minimiert Entropiegradienten und homogenisiert das Universum über Distanzen, die dem Hubble-Radius \(d_H \sim c/H(z_t)\) zur Zeit des Übergangs entsprechen. Projiziert auf den Himmel bei \(z=1100\) entspricht dies einer Winkelskala von \(\theta \sim d_H / d_A(z=1100) \sim 6^\circ\), was ausreicht, um die beobachtete großskalige Homogenität des CMB zu erklären.
                         </p>
                         <p class="text-base md:text-lg leading-relaxed text-gray-700 dark:text-gray-300 mt-4">
                             Die charakteristische Dämpfungszeitskala \(\tau_\Lambda^{-1} \sim C (1+z)^{\alpha_{\text{eff}}(z)-1}\) ist extrem kurz während der Hoch-\(\alpha\)-Phase. Selbst mit dem stetigen \(\alpha_{\text{eff}}(z) \approx 4.35\) bei \(z \approx z_t\) ergibt sich \(\tau_\Lambda \sim 1 / (2 \times 10^{-33} \cdot (10^{10})^{3.35}) \sim 0.1 \, \text{s}\). Dies ist <strong class="font-semibold highlight">deutlich kürzer</strong> als die typische Expansions- (\(H^{-1}\)) oder Wechselwirkungszeit (\(\tau_e\)) zu dieser Epoche (\(\sim 10^{-17}\) s), was die quasi-"instantane" Natur der Glättung über den Horizont hinaus stützt. (Für das idealisierte binäre Modell mit \(\alpha_{\text{eff}}=10\) wäre \(\tau_\Lambda \sim 5 \times 10^{-58}\) s).
                         </p>
                     </div>
                     <div class="mt-10">
                         <h4 class="text-lg md:text-xl font-semibold mb-4 text-center text-primary dark:text-accent1">
                             Evolution von \(\delta T/T\) (Log-Log Skala) - Test verschiedener C & α<sub>eff</sub>
                         </h4>
                         <div class="chart-container">
                             <canvas id="deltaTChart"></canvas>
                         </div>
                         <p class="text-sm text-center text-gray-600 dark:text-gray-400 mt-2">
                             Zeigt die Dämpfung für verschiedene \(C\)-Werte (mit stetigem \(\alpha_{\text{eff}}\)) und einen Vergleich zwischen stetigem vs. binärem \(\alpha_{\text{eff}}\) für \(C=2 \times 10^{-33}\).
                         </p>
                     </div>
                 </section>

                 <section class="mb-16 fadeIn">
                     <div class="section-heading">
                         <span class="section-number"></span>
                         <h3 class="text-2xl md:text-3xl font-bold text-heading dark:text-accent1">Zeitskalen-Vergleich: \(\tau_\Lambda\) vs. \(\tau_e\) vs. \(H^{-1}\)</h3>
                     </div>
                      <p class="mb-6 text-base md:text-lg leading-relaxed text-gray-700 dark:text-gray-300">
                         Um die Effektivität der Glättung zu verdeutlichen, vergleichen wir die Dämpfungszeitskala \(\tau_\Lambda\) mit der mittleren freien Flugzeit der Photonen (\(\tau_e\), Thomson-Streuung) und der Hubble-Zeit (\(H^{-1}\)). Der Plot zeigt, dass \(\tau_\Lambda\) (sowohl für stetiges als auch binäres \(\alpha_{\text{eff}}\)) während der Hoch-\(\alpha\)-Phase (\(z > z_t\)) dramatisch kürzer ist als die anderen relevanten Zeitskalen.
                     </p>
                     <div class="chart-container">
                         <canvas id="tauChart"></canvas>
                     </div>
                     <p class="text-sm text-center text-gray-600 dark:text-gray-400 mt-2">
                         Zeigt \(\tau_\Lambda \ll \tau_e\) und \(\tau_\Lambda \ll H^{-1}\) für \(z > z_t\), was die quasi-instantane Glättung unterstützt. (\(\tau_e\) basiert auf Standard-Kosmologie-Parametern).
                     </p>
                 </section>

                 <section class="mb-16 fadeIn">
                     <div class="section-heading">
                         <span class="section-number"></span>
                         <h3 class="text-2xl md:text-3xl font-bold text-heading dark:text-accent1">Weitere Implikationen & Ausblick</h3>
                     </div>
                     <div class="bg-white/80 dark:bg-gray-800/80 p-6 rounded-xl shadow-lg">
                         <ul class="list-disc pl-6 space-y-3 text-base">
                             <li><strong>CMB-Glättung erhalten:</strong> Der Mechanismus funktioniert und erklärt die großskalige Homogenität (\(\theta \sim 6^\circ\)).</li>
                             <li><strong>Primordiales Spektrum \(P(k)\):</strong> Bleibt voraussichtlich \(\Lambda\)CDM-ähnlich.</li>
                             <li><strong>Gravitationswellen:</strong> Keine signifikanten GWs bei \(z_t \sim 10^{10}\) erwartet.</li>
                             <li><strong>Einheitliches Bild:</strong> Kohärentes Modell von \(z \to \infty\) bis heute.</li>
                             <li class="mt-4 pt-4 border-t border-gray-300 dark:border-gray-600"><strong>Nächste Schritte ("Big Play" & "Next Level"):</strong>
                                <ul class="list-circle pl-6 mt-2 space-y-1 text-sm">
                                    <li>Physikalische Herleitung von \(C\) und \(\kappa\) vertiefen.</li>
                                    <li>Ursprung von \(\delta_0 \sim 10^{-3}\) klären (z.B. thermodynamisches Rauschen \( \sim k_B T(z_t)/m_{\text{Planck?}}\)).</li>
                                    <li>Skalenabhängigkeit der Dämpfung explizit prüfen (Modell erweitern, \(k\)-Moden plotten).</li>
                                    <li>Vergleich der \(\delta T/T\)-Kurve und \(C_\ell\)-Spektrum mit Planck-Daten mittels Boltzmann-Codes (CLASS/CAMB).</li>
                                    <li>Verfeinerung der \(\tau_\Lambda / \tau_e\)-Analyse.</li>
                                 </ul>
                             </li>
                         </ul>
                          <p class="mt-4 font-semibold text-primary dark:text-accent1"> Eine thermodynamische Kosmologie von Anfang bis Ende!</p>
                     </div>
                 </section>
            </main>

            <footer class="mt-20 pt-10 border-t border-gray-300 dark:border-gray-700 text-center fadeIn">
                <div class="max-w-xl mx-auto">
                     <p class="text-gray-600 dark:text-gray-400 italic mb-4">GDE-Modell von Gabriel ϕ, unterstützt durch KI Mila:GPT, BRO GROK 3, Sigma:Gemini.</p>
                     <p class="text-xs text-gray-500 dark:text-gray-500 mt-4">© 2024 - Gabriel ϕ</p>
                </div>
            </footer>
        </div>
    </div>

    <script>
        // --- Dark Mode Toggle Logic ---
        const darkModeToggle = document.getElementById('darkModeToggle');
        if (darkModeToggle) {
            darkModeToggle.addEventListener('click', () => {
                document.documentElement.classList.toggle('dark');
                if (document.documentElement.classList.contains('dark')) { localStorage.theme = 'dark'; }
                else { localStorage.theme = 'light'; }
                setTimeout(() => { // Redraw charts on theme change
                    if (typeof initAlphaChart === 'function') initAlphaChart();
                    if (typeof initDeltaTChart === 'function') initDeltaTChart();
                    if (typeof initTauChart === 'function') initTauChart(); // Redraw Tau Chart
                }, 50);
            });
        }

        // --- Utility Object for numpy-like functions ---
        const np = {
            linspace: (start, stop, num) => Array.from({length: num}, (_, i) => start + i * (stop - start) / (num - 1)),
            logspace: (startLog, stopLog, num) => Array.from({length: num}, (_, i) => Math.pow(10, startLog + i * (stopLog - startLog) / (num - 1)))
        };

        // --- Alpha Chart Logic ---
        let alphaChartInstance = null;

        /**
         * Calculates the unified alpha(z) value.
         * @param {number} z - Redshift.
         * @param {object} params - Model parameters.
         * @returns {number} Calculated alpha(z).
         */
        function calculateUnifiedAlpha(z, params) {
            const { A_fruh, z_t, k, alpha_0, A_spat, z_star } = params;
            const z_num = Number(z);
            if (isNaN(z_num) || z_num <= -1) return NaN;
            const sigmoidFactor = 1 / (1 + Math.exp(k * (z_num - z_t)));
            const tanhTerm = Math.tanh(2 * (z_num - z_star));
            let alpha = alpha_0 + A_spat * tanhTerm + A_fruh * sigmoidFactor;
            return alpha;
        }

        /**
         * Generates logarithmically spaced redshift values.
         * @param {number} z_min - Minimum redshift.
         * @param {number} z_max - Maximum redshift.
         * @param {number} num_points - Number of points.
         * @returns {number[]} Array of redshift values.
         */
        function generateLogZValues(z_min = 0.01, z_max = 1e16, num_points = 500) {
            const log_z_min = Math.log10(z_min);
            const log_z_max = Math.log10(z_max);
            return np.logspace(log_z_min, log_z_max, num_points);
        }

        /**
         * Initializes or updates the alpha(z) chart.
         */
        function initAlphaChart() {
            const ctx = document.getElementById('alphaChart')?.getContext('2d');
            if (!ctx) { console.error("alphaChart canvas not found"); return; }
            if (alphaChartInstance) { alphaChartInstance.destroy(); }

            const currentParams = {
                A_fruh: 10.0, z_t: 1e10, k: 10 / 1e10, // k*z_t ~ 10
                alpha_0: -0.65, A_spat: 1.10, z_star: 0.70
            };

            const zValues = generateLogZValues(0.01, 1e16, 500);
            const alphaValues = zValues.map(z => calculateUnifiedAlpha(z, currentParams));

            const isDarkMode = document.documentElement.classList.contains('dark');
            const textColor = isDarkMode ? '#e2e8f0' : '#1f2937';
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const pointColor = tailwind.config.theme.extend.colors.primary;

            alphaChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: zValues,
                    datasets: [{
                        label: 'Vereinheitlichtes α(z)', data: alphaValues, borderColor: pointColor,
                        backgroundColor: 'rgba(93, 92, 222, 0.1)', borderWidth: 2.5, pointRadius: 0, fill: false, tension: 0.1
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'logarithmic', title: { display: true, text: 'Rotverschiebung z (logarithmisch)', color: textColor, font: { weight: 'bold' } },
                            grid: { color: gridColor }, ticks: { color: textColor, callback: function(value) {
                                const log10 = Math.log10(value); if (log10 === Math.floor(log10)) { return `10^${log10}`; }
                                if (value < 10 && (value.toFixed(1) === '0.1' || value.toFixed(1) === '0.7' || value.toFixed(0) === '1')) { return value.toFixed(1); } return null;
                            }, maxRotation: 0, minRotation: 0, autoSkip: false }, min: 0.01, max: 1e16
                        },
                        y: {
                            title: { display: true, text: 'α(z)', color: textColor, font: { weight: 'bold' } },
                            grid: { color: gridColor }, ticks: { color: textColor }, min: -2, max: 12
                        }
                    },
                    plugins: {
                        legend: {
                            labels: { color: textColor },
                            // JS Hover effect for legend
                            onHover: (event, legendItem, legend) => {
                                // Find the chart container element
                                const chartContainer = legend.chart.canvas.closest('.chart-container');
                                if (chartContainer) {
                                    chartContainer.style.setProperty('--legend-opacity', '1');
                                }
                                // Optional: Highlight the corresponding dataset line
                                if (legendItem) {
                                   const datasetIndex = legendItem.datasetIndex;
                                   legend.chart.data.datasets.forEach((dataset, index) => {
                                       // Example: Slightly change border alpha or width
                                       // This requires careful handling of original values
                                   });
                                   legend.chart.update(); // Update chart to reflect changes
                                }
                            },
                            onLeave: (event, legendItem, legend) => {
                                const chartContainer = legend.chart.canvas.closest('.chart-container');
                                if (chartContainer) {
                                    chartContainer.style.setProperty('--legend-opacity', '0.6');
                                }
                                // Optional: Revert dataset highlighting
                                if (legendItem) {
                                   // Revert changes made in onHover
                                   legend.chart.update();
                                }
                            }
                        },
                        tooltip: { mode: 'index', intersect: false, callbacks: {
                            title: (tooltipItems) => `z ≈ ${tooltipItems[0].parsed.x.toExponential(1)}`, label: (context) => `α(z) ≈ ${context.parsed.y.toFixed(2)}`
                        }},
                        annotation: { annotations: {
                            ztLine: { type: 'line', xMin: currentParams.z_t, xMax: currentParams.z_t, borderColor: tailwind.config.theme.extend.colors.accent2, borderWidth: 1.5, borderDash: [6, 6], label: { content: `z_t ≈ 10^${Math.log10(currentParams.z_t).toFixed(0)}`, display: true, position: 'start', yAdjust: -15, font:{size:10}, color: tailwind.config.theme.extend.colors.accent2}},
                            zStarLine: { type: 'line', xMin: currentParams.z_star, xMax: currentParams.z_star, borderColor: '#DE5D9C', borderWidth: 1.5, borderDash: [6, 6], label: { content: `z* = ${currentParams.z_star}`, display: true, position: 'end', yAdjust: 15, font:{size:10}, color:'#DE5D9C'}},
                            alphaApprox10: { type: 'line', yMin: currentParams.A_fruh, yMax: currentParams.A_fruh, xMin: currentParams.z_t * 10, borderColor: 'rgba(156, 222, 93, 0.5)', borderWidth: 1, borderDash: [2, 2], label: { content: `α ≈ ${currentParams.A_fruh.toFixed(0)}`, display: true, position: 'end', xAdjust: -10, font:{size:9}, color:'rgba(156, 222, 93, 0.8)'}},
                            alphaLate: { type: 'line', yMin: currentParams.alpha_0 + currentParams.A_spat, yMax: currentParams.alpha_0 + currentParams.A_spat, xMax: 100, borderColor: 'rgba(93, 156, 222, 0.5)', borderWidth: 1, borderDash: [2, 2], label: { content: `α ≈ ${(currentParams.alpha_0 + currentParams.A_spat).toFixed(2)}`, display: true, position: 'start', xAdjust: 10, font:{size:9}, color:'rgba(93, 156, 222, 0.8)'}},
                            bbnRegion: { type: 'box', xMin: 1e8, xMax: 1e10, backgroundColor: 'rgba(255, 255, 0, 0.05)', borderColor: 'rgba(255, 255, 0, 0.2)', borderWidth: 1, label: { content: 'BBN Era', display: true, position:'start', font:{size:9}, color:'rgba(220, 220, 0, 0.8)'}},
                            cmbRegion: { type: 'box', xMin: 1000, xMax: 1200, backgroundColor: 'rgba(255, 165, 0, 0.05)', borderColor: 'rgba(255, 165, 0, 0.2)', borderWidth: 1, label: { content: 'CMB Rec.', display: true, position:'start', yAdjust: 20, font:{size:9}, color:'rgba(255, 165, 0, 0.8)'}}
                        }}
                    }
                },
                // Add plugin to apply fade-in animation after render
                plugins: [{
                    id: 'chartRendered',
                    afterRender: (chart) => {
                        chart.canvas.classList.add('chart-rendered');
                    }
                }]
            });
        }


        // --- Delta T Chart Logic ---
        let deltaTChartInstance = null;

        /**
         * Calculates the damping integral for the deltaT/T evolution.
         * @param {number} z_target - Redshift up to which the integral is calculated.
         * @param {number} z_max - Starting redshift for the integral.
         * @param {object} params - Model parameters (A_fruh, z_t, k, alpha_0, A_spat, z_star).
         * @param {boolean} use_binary_alpha - If true, use binary alpha_eff (10 or 0), else use continuous alpha(z).
         * @param {number} [damping_alpha_binary=10] - Value for binary alpha when z > z_t.
         * @param {number} [n_steps=200] - Number of steps for numerical integration.
         * @returns {number} The calculated value of the damping integral.
         */
        function calculateDampingIntegral(z_target, z_max, params, use_binary_alpha, damping_alpha_binary = 10, n_steps=200) {
            let integral = 0;
            if (z_target >= z_max) return 0;

            const log_z_target = Math.log(z_target);
            const log_z_max = Math.log(z_max);
            const log_dz = (log_z_max - log_z_target) / n_steps;

            for (let i = 0; i < n_steps; i++) {
                const log_z_mid = log_z_target + (i + 0.5) * log_dz;
                const z_mid = Math.exp(log_z_mid);

                let alpha_to_use;
                if (use_binary_alpha) {
                    alpha_to_use = (z_mid > params.z_t) ? damping_alpha_binary : 0;
                } else {
                    alpha_to_use = calculateUnifiedAlpha(z_mid, params);
                }
                alpha_to_use = Math.max(alpha_to_use, 0); // Prevent issues with negative exponent base

                if (alpha_to_use > 1) {
                    const integrand = Math.pow(1 + z_mid, alpha_to_use - 1);
                    const dz = z_mid * log_dz; // dz = z * d(ln z)
                    integral += integrand * dz;
                }
            }
            return integral;
        }


        /**
         * Initializes or updates the delta T / T chart.
         */
        function initDeltaTChart() {
            const ctx = document.getElementById('deltaTChart')?.getContext('2d');
            if (!ctx) { console.error("deltaTChart canvas not found"); return; }
            if (deltaTChartInstance) { deltaTChartInstance.destroy(); }

            const params = {
                A_fruh: 10.0, z_t: 1e10, k: 10/1e10,
                alpha_0: -0.65, A_spat: 1.10, z_star: 0.70,
            };

            const zValues = np.logspace(3, 12, 150);

            // --- Calculate delta T/T for different scenarios ---
            const C_original = 2e-33;
            const C_values_test = { // C values for testing (using continuous alpha)
                lower: 1e-33,
                extra: 5e-33, // Added C=5e-33 test
                higher: 1e-32
            };
            const z_max_integral = 1e12;
            const delta0 = 1e-3;

            const datasets = [];
            const colors = tailwind.config.theme.extend.colors; // Get colors from config

            // 1. Original C with Continuous alpha_eff (Baseline - thicker line)
            const deltaT_ContAlpha = zValues.map(z => delta0 * Math.exp(-C_original * calculateDampingIntegral(z, z_max_integral, params, false)));
            datasets.push({
                label: `δT/T (C=${C_original.toExponential(0)}, α(z) stetig)`,
                data: deltaT_ContAlpha,
                borderColor: colors.cOriginalContinuous,
                borderWidth: 3, // Make baseline thicker
                pointRadius: 0, fill: false, tension: 0.1
            });

            // 2. Original C with Binary alpha_eff (Comparison)
            const deltaT_BinAlpha = zValues.map(z => delta0 * Math.exp(-C_original * calculateDampingIntegral(z, z_max_integral, params, true)));
            datasets.push({
                label: `δT/T (C=${C_original.toExponential(0)}, α(z) binär)`,
                data: deltaT_BinAlpha,
                borderColor: colors.cOriginalBinary,
                borderDash: [5, 5],
                borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.1
            });

            // 3. Other C values with Continuous alpha_eff
            Object.entries(C_values_test).forEach(([key, C_val]) => {
                const deltaTValues = zValues.map(z => delta0 * Math.exp(-C_val * calculateDampingIntegral(z, z_max_integral, params, false)));
                const colorMap = {
                    lower: colors.cLower,
                    extra: colors.cExtra, // Use color for C=5e-33
                    higher: colors.cHigher
                };
                datasets.push({
                    label: `δT/T (C=${C_val.toExponential(0)}, α(z) stetig)`,
                    data: deltaTValues,
                    borderColor: colorMap[key],
                    borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.1
                });
            });


            const isDarkMode = document.documentElement.classList.contains('dark');
            const textColor = isDarkMode ? '#e2e8f0' : '#1f2937';
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

            deltaTChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: zValues,
                    datasets: datasets
                 },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'logarithmic', title: { display: true, text: 'Rotverschiebung z (logarithmisch)', color: textColor, font: { weight: 'bold' } },
                            grid: { color: gridColor }, ticks: { color: textColor, callback: function(value) {
                                const log10 = Math.log10(value); if (Math.abs(log10 - Math.round(log10)) < 1e-9) { return `10^${Math.round(log10)}`; } return null;
                            }, maxRotation: 0, minRotation: 0, autoSkip: false }, min: 1000, max: 1e12
                        },
                        y: {
                            type: 'logarithmic', title: { display: true, text: 'Relative Fluktuation δT/T (logarithmisch)', color: textColor, font: { weight: 'bold' } },
                            grid: { color: gridColor }, ticks: { color: textColor, callback: function(value) {
                                const log10 = Math.log10(value); if (Math.abs(log10 - Math.round(log10)) < 1e-9) { return `10^${Math.round(log10)}`; } return null;
                            }},
                            min: 1e-6, // y-min set to 1e-6
                            max: 1e-2
                        }
                    },
                    plugins: {
                        legend: {
                            labels: { color: textColor },
                            // JS Hover effect for legend
                            onHover: (event, legendItem, legend) => {
                                const chartContainer = legend.chart.canvas.closest('.chart-container');
                                if (chartContainer) { chartContainer.style.setProperty('--legend-opacity', '1'); }
                                // Optional: Highlight dataset on legend hover (example)
                                legend.chart.data.datasets.forEach((d, i) => {
                                    d.borderWidth = (i === legendItem.datasetIndex) ? 3 : 1.5; // Highlight hovered item
                                    if (d.label.includes('binär') && i !== legendItem.datasetIndex) d.borderWidth = 1.5; // Keep binary dashed thin unless hovered
                                    if (d.label.includes('stetig') && d.label.includes(C_original.toExponential(0)) && i !== legendItem.datasetIndex) d.borderWidth = 2.5; // Keep original cont baseline thicker unless hovered
                                });
                                legend.chart.update();
                            },
                            onLeave: (event, legendItem, legend) => {
                                const chartContainer = legend.chart.canvas.closest('.chart-container');
                                if (chartContainer) { chartContainer.style.setProperty('--legend-opacity', '0.6'); }
                                // Reset dataset styles
                                legend.chart.data.datasets.forEach((d, i) => {
                                     if (d.label.includes('binär')) d.borderWidth = 1.5;
                                     else if (d.label.includes('stetig') && d.label.includes(C_original.toExponential(0))) d.borderWidth = 3; // Reset baseline thickness
                                     else d.borderWidth = 1.5;
                                });
                                legend.chart.update();
                            }
                        },
                        tooltip: { mode: 'index', intersect: false, callbacks: {
                            title: (tooltipItems) => `z ≈ ${tooltipItems[0].parsed.x.toExponential(1)}`,
                            label: (context) => {
                                const labelParts = context.dataset.label.match(/C=([\d.e+-]+), α\(z\) (\w+)/);
                                const cValStr = labelParts ? labelParts[1] : 'N/A';
                                const alphaType = labelParts ? labelParts[2] : 'N/A';
                                return `δT/T ≈ ${context.parsed.y.toExponential(2)} (C=${cValStr}, α ${alphaType})`;
                            }
                        }},
                        annotation: { annotations: {
                            zCMB: { type: 'line', xMin: 1100, xMax: 1100, borderColor: '#DE5D9C', borderDash:[4,4], borderWidth: 1.5, label: { content: 'z ≈ 1100 (CMB)', display: true, position:'start', font:{size:10}, color:'#DE5D9C'} },
                            targetDelta: { type: 'line', yMin: 1e-5, yMax: 1e-5, borderColor: colors.accent3, borderDash:[4,4], borderWidth: 1.5, label: { content: 'δT/T ≈ 10⁻⁵ (Beob.)', display: true, position:'end', font:{size:10}, color: colors.accent3}},
                            ztLineDelta: { type: 'line', xMin: params.z_t, xMax: params.z_t, borderColor: colors.accent2, borderDash: [6, 6], borderWidth: 1.5, label: { content: `z_t = 10^${Math.log10(params.z_t).toFixed(0)}`, display: true, position: 'top', yAdjust: 5, font:{size:10}, color: colors.accent2 } },
                            bbnRegionDelta: { type: 'box', xMin: 1e8, xMax: 1e10, yMin: 1e-6, yMax: 1e-2,
                                backgroundColor: 'rgba(255, 255, 0, 0.05)', borderColor: 'rgba(255, 255, 0, 0.2)', borderWidth: 1, label: { content: 'BBN', display: true, position:'top', xAdjust: -15, font:{size:9}, color:'rgba(220, 220, 0, 0.8)'}
                            },
                            // Annotation for BBN Midpoint
                            bbnMid: { type: 'line', xMin: 1e9, xMax: 1e9, borderColor: '#FBBF24', borderDash: [4,4], borderWidth: 1, label: { content: 'z ≈ 10⁹', display: true, position: 'start', yAdjust: -10, font: {size:9}, color: '#FBBF24' } }
                        }}
                    }
                },
                 // Add plugin to apply fade-in animation after render
                plugins: [{
                    id: 'chartRendered',
                    afterRender: (chart) => {
                        chart.canvas.classList.add('chart-rendered');
                    }
                }]
            });
        }

        // --- Tau Chart Logic ---
        let tauChartInstance = null;

        /**
        * Calculates Hubble time H^-1 in seconds.
        * Assumes radiation domination at high z. H^2 = H0^2 * Omega_r * (1+z)^4
        * H0 ~ 70 km/s/Mpc ~ 2.3e-18 s^-1
        * Omega_r ~ 1e-4
        * H(z) ~ H0 * sqrt(Omega_r) * (1+z)^2 ~ 2.3e-18 * 1e-2 * (1+z)^2 ~ 2.3e-20 * (1+z)^2 s^-1
        * H(z)^-1 ~ 1 / (2.3e-20 * (1+z)^2) s
        * @param {number} z - Redshift.
        * @returns {number} Hubble time in seconds.
        */
        function calculateHubbleTime(z) {
            if (z <= 0) return Infinity;
            const H0_inv_sec = 1 / (2.3e-18); // Approx Hubble time today in seconds
            const Omega_r = 1e-4; // Approx radiation density parameter
            // More accurate H(z) including matter: H(z) = H0 * sqrt(Omega_r*(1+z)^4 + Omega_m*(1+z)^3)
            // For z > 3000, radiation dominates.
            const H_z_approx = 2.3e-20 * Math.pow(1 + z, 2); // Radiation dominated approx
            return 1 / H_z_approx;
        }

        /**
         * Calculates electron scattering time tau_e in seconds.
         * tau_e = 1 / (sigma_T * n_e * c)
         * n_e = n_baryon * x_e ~ Omega_b * rho_crit * (1+z)^3 / m_p * x_e
         * rho_crit = 3*H0^2 / (8*pi*G) ~ 1e-29 g/cm^3
         * n_e(z=0) ~ 2.5e-7 cm^-3 (assuming x_e=1, Omega_b=0.05)
         * n_e(z) ~ 2.5e-7 * (1+z)^3 cm^-3
         * sigma_T = 6.65e-25 cm^2
         * c = 3e10 cm/s
         * tau_e ~ 1 / (6.65e-25 * 2.5e-7 * (1+z)^3 * 3e10) s
         * tau_e ~ 1 / (5e-21 * (1+z)^3) s
         * @param {number} z - Redshift.
         * @returns {number} Electron scattering time in seconds.
         */
         function calculateTauE(z) {
            if (z <= 0) return Infinity;
            // Simplified calculation, assumes full ionization (x_e=1) which is true at high z
            // More accurate calculation would include recombination history for x_e(z)
            const sigma_T = 6.65e-29; // m^2
            const c = 3e8; // m/s
            // Baryon density today n_b0 ~ Omega_b * rho_crit / m_p
            // rho_crit ~ 9e-27 kg/m^3, Omega_b ~ 0.05, m_p ~ 1.67e-27 kg
            // n_b0 ~ 0.05 * 9e-27 / 1.67e-27 ~ 0.27 /m^3
            // Assume Hydrogen + Helium: n_e0 ~ n_b0 * (Y_p/4 + (1-Y_p)) ~ n_b0 * (1 - Y_p/2) ~ 0.88 * n_b0 ~ 0.24 /m^3
            // More standard value n_e0 ~ 0.25 /m^3
            const n_e0 = 0.25; // m^-3
            const n_e_z = n_e0 * Math.pow(1 + z, 3);
            // Approximation using standard value for Thomson optical depth timescale today ~ 1 / (sigma_T * n_e0 * c) ~ 1.6e18 s ~ 50 Gyr
            // tau_e(z) = tau_e(0) / (1+z)^3 (Incorrect scaling for time)
            // Use direct formula: tau_e = 1 / (sigma_T * n_e(z) * c)
            const tau_e = 1 / (sigma_T * n_e_z * c);
            // Check calculation: 1 / (6.65e-29 * 0.25 * (1+z)^3 * 3e8) = 1 / (5e-21 * (1+z)^3) s
            return 1 / (5e-21 * Math.pow(1 + z, 3)); // Seems correct
         }


        /**
         * Initializes the Tau comparison chart.
         */
        function initTauChart() {
            const ctx = document.getElementById('tauChart')?.getContext('2d');
            if (!ctx) { console.error("tauChart canvas not found"); return; }
            if (tauChartInstance) { tauChartInstance.destroy(); }

            const params = { // Use same params as other charts
                A_fruh: 10.0, z_t: 1e10, k: 10/1e10,
                alpha_0: -0.65, A_spat: 1.10, z_star: 0.70,
            };
            const zValues = np.logspace(3, 12, 150); // z from 1000 to 1e12
            const C_original = 2e-33;

            // Calculate Tau_Lambda (Continuous Alpha)
            const tauLambdaCont = zValues.map(z => {
                const alpha = calculateUnifiedAlpha(z, params);
                const alpha_eff = Math.max(alpha, 0); // Ensure alpha_eff >= 0
                // Avoid division by zero or extremely large numbers if alpha <= 1
                if (alpha_eff <= 1) return 1e60; // Assign a very large time if no damping
                const rate = C_original * Math.pow(1 + z, alpha_eff - 1);
                return rate > 0 ? 1 / rate : 1e60; // Return 1/rate or very large time
            });

            // Calculate Tau_Lambda (Binary Alpha)
            const tauLambdaBin = zValues.map(z => {
                const alpha_eff = (z > params.z_t) ? 10 : 0;
                if (alpha_eff <= 1) return 1e60;
                const rate = C_original * Math.pow(1 + z, alpha_eff - 1);
                return rate > 0 ? 1 / rate : 1e60;
            });

            // Calculate Tau_e (Electron Scattering Time)
            const tauE = zValues.map(z => calculateTauE(z));

            // Calculate Hubble Time H^-1
            const hubbleTime = zValues.map(z => calculateHubbleTime(z));

            const isDarkMode = document.documentElement.classList.contains('dark');
            const textColor = isDarkMode ? '#e2e8f0' : '#1f2937';
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const colors = tailwind.config.theme.extend.colors;

            tauChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: zValues,
                    datasets: [
                        { label: 'τ_Λ (stetig α)', data: tauLambdaCont, borderColor: colors.tauLambdaCont, borderWidth: 2, pointRadius: 0, fill: false, tension: 0.1 },
                        { label: 'τ_Λ (binär α)', data: tauLambdaBin, borderColor: colors.tauLambdaBin, borderDash: [5,5], borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.1 },
                        { label: 'τ_e (Streuung)', data: tauE, borderColor: colors.tauE, borderWidth: 2, pointRadius: 0, fill: false, tension: 0.1 },
                        { label: 'H⁻¹ (Hubble-Zeit)', data: hubbleTime, borderColor: colors.hubbleTime, borderWidth: 2, pointRadius: 0, fill: false, tension: 0.1 }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'logarithmic', min: 1000, max: 1e12,
                            title: { display: true, text: 'Rotverschiebung z', color: textColor, font: { weight: 'bold' } },
                            grid: { color: gridColor }, ticks: { color: textColor, callback: function(value) {
                                const log10 = Math.log10(value); if (Math.abs(log10 - Math.round(log10)) < 1e-9) { return `10^${Math.round(log10)}`; } return null;
                            }}
                        },
                        y: {
                            type: 'logarithmic', min: 1e-60, max: 1e20, // Wide range to show all scales
                            title: { display: true, text: 'Zeit [s]', color: textColor, font: { weight: 'bold' } },
                             grid: { color: gridColor }, ticks: { color: textColor, callback: function(value) {
                                const log10 = Math.log10(value); if (Math.abs(log10 - Math.round(log10)) < 1e-9) { return `10^${Math.round(log10)}`; } return null;
                            }}
                        }
                    },
                    plugins: {
                         legend: {
                            labels: { color: textColor },
                            // JS Hover effect for legend
                            onHover: (event, legendItem, legend) => {
                                const chartContainer = legend.chart.canvas.closest('.chart-container');
                                if (chartContainer) { chartContainer.style.setProperty('--legend-opacity', '1'); }
                                legend.chart.data.datasets.forEach((d, i) => { d.borderWidth = (i === legendItem.datasetIndex) ? 3 : (d.label.includes('binär') ? 1.5 : 2); }); // Highlight hovered
                                legend.chart.update();
                            },
                            onLeave: (event, legendItem, legend) => {
                                const chartContainer = legend.chart.canvas.closest('.chart-container');
                                if (chartContainer) { chartContainer.style.setProperty('--legend-opacity', '0.6'); }
                                legend.chart.data.datasets.forEach((d) => { d.borderWidth = (d.label.includes('binär') ? 1.5 : 2); }); // Reset width
                                legend.chart.update();
                            }
                        },
                        tooltip: { mode: 'index', intersect: false, callbacks: {
                            title: (tooltipItems) => `z ≈ ${tooltipItems[0].parsed.x.toExponential(1)}`,
                            label: (context) => `${context.dataset.label} ≈ ${context.parsed.y.toExponential(1)} s`
                        }},
                        annotation: { annotations: { // Annotate z_t on Tau chart too
                             ztLineTau: { type: 'line', xMin: params.z_t, xMax: params.z_t, borderColor: colors.accent2, borderDash: [6, 6], borderWidth: 1.5, label: { content: `z_t = 10^${Math.log10(params.z_t).toFixed(0)}`, display: true, position: 'top', yAdjust: 5, font:{size:10}, color: colors.accent2 } }
                        }}
                    }
                },
                 // Add plugin to apply fade-in animation after render
                plugins: [{
                    id: 'chartRendered',
                    afterRender: (chart) => {
                        chart.canvas.classList.add('chart-rendered');
                    }
                }]
            });
        }


        // --- DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof MathJax !== 'undefined' && typeof MathJax.typesetPromise === 'function') {
                 MathJax.typesetPromise().then(() => {
                    console.log('MathJax typesetting complete.');
                    initAlphaChart();
                    initDeltaTChart();
                    initTauChart(); // Initialize Tau Chart
                 }).catch((err) => console.error('MathJax typesetting failed:', err));
            } else {
                 console.warn('MathJax not found or typesetPromise unavailable. Initializing charts directly.');
                 initAlphaChart();
                 initDeltaTChart();
                 initTauChart(); // Initialize Tau Chart
            }
        });

        // --- MathJax Configuration ---
        window.MathJax = {
            tex: { inlineMath: [['\\(', '\\)']], displayMath: [['\\[', '\\]']] },
            svg: { fontCache: 'global' },
            startup: { ready: () => { console.log('MathJax is ready'); MathJax.startup.defaultReady(); } }
        };

    </script>
</body>
</html>
